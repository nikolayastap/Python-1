      # Рекурсия и Алгоритмы

  # Задача 31
# Последовательностью Фибоначчи называется последовательность чисел
# a0, a1, ....aN, где a0 = 0, a1 = 1, aK = aK-1 + aK-2 (K>1)
# Необходимо найти N-е число Фибоначчи
# 7 -> 13
# f(n) = f(n -1) + f(n - 2) функция Фибоначчи

def f(n):
  if n == 0 or n == 1:
    return 1
  return f(n - 1) + f(n - 2)

n = int(input("Введите номер: "))
print(f(n - 2)) # -2 так как первые 2а эл извесна

# Обяснение Дениса
from datetime import datetime # Импортировали обект для замера времени

def f(n):
  if n in (0, 1): # Точка выхода из рекурсии
    return n
  return f(n - 1) + f(n - 2)

n = int(input("Введите номер: "))
start_time = datetime.now() # Для запуска таймера
print(f(n))
print(f'Время работы: {datetime.now() - start_time}') # решение через рекурсию работает в разы дольше

# Стек вызовов
# f(5) ->                   f(4) + f(3)
#                              |
#                       2=f(3) +             f(2) = 1+0
#                           |                 |
#                   1+0=f(2) +   f(1)=1      f(1) + f(0)
#                        |        |           |      |
#                   f(1) + f(0)   1           1      0
#                     |      |
#                     1      0
# Сложность работы данного алгоритма О(2^n)
# Сложность работы при поисе 10 - О(2^10) = 1024 опереции

a0 = 0
a1 = 1
start_time = datetime.now()
for i in range(n):
  a_next = a0 + a1
  a0 = a1
  a1 = a_next
print(a0)
print(f'Время работы: {datetime.now() - start_time}')
# Сложность работы линейной программы O(n) = 10 операций



  # Задача 33
# Хакер Василий получил доступ к классному журналу и хочет заменить все
# свои мин оценки на макс. Программа, которая заменяет оценки Василия,
# но наоборот: все макс на мин
# 5 - 1 3 3 3 4 -> 1 3 3 3 1

n = int(input()) # Вводим кол-во элементов массива
list1 = list() # Создаем список
for i in range(n): # Заполняем цикл
  x = int(input()) # При каждой итерации цикла вводим число и добовляем в список
  list1.append(x) # С помощю функции append
max_n = max(list1) # Чтобы найти максимал эл применяем к списку функцию max
min_n = min(list1) # Чтобы найти минималый эл применяем к списку функцию max
for i in range(len(list1)): # Создаем цикл, который будет проходить по кажд эл
  if list1[i] == max_n: # Если эл равен максимуму 
    list1[i] = min_n # То заменяем на минимум
print(list1)

# Обяснение Дениса
marks = [int(i) for i in input("Введите оценки: ").split()]
print(*[min(marks) if i == max(marks) else i for i in marks]) # Внутри
# (for i in marks) проходим по каждому элементу введенного списка,
# (if i == max(marx)) еси нашли эл который является max значением, то
# сохраняем ([min(marks)) минимальное значение, в любом другом случае
# (else i) сохраняем само это значение
# min(marks) - поиск минимального числа списка
# min(marks) - поиск максимальног числа списка



  # Задача 35
# Напишите функцию, которая принимает одно число и проверяет, является
# ли оно простым (делется на 1 и на себя)
# 5 -> yes

def prime(n): # Передаем искомое число
  flag = True # Флажек для цикла
  i = 2 # Счетчик цикла, так как мы знаем, что все цифры делятся на 1, проверять это не нужно
  while i < n and flag:
    if n % i == 0:
      flag = False
    i +=1
  if flag:
    return 'yes'
  else:
    return 'no'

n = int(input())
print(prime(n))

# Обяснение Дениса
def is_prime(n):
  for i in range(2, n // 2 + 1): # Идем от 2, до половины этого числа(+1 так как range не включает конечное значение)
    if n % i == 0: # Если в этом промежутке встретится делитель числа (делится без остатка)
      return 'no' # То выводим no
  return 'yes' # Если деитель не встречается то возращается yes

print(is_prime(int(input("Введите число: "))))



  # Задача 37
# Дано натуральное число N и последовательность из N эл. Требуется
# вывести эту последовательность в обратном порядке.
# 2-34 -> 43

def f(n):
  if n == 0: # База (место гре выходим из рекурсии)
    return '' # То возращаем пустую строку
  k = int(input()) # Вводим последовательность
  return f(n - 1) + f'{k}' # Введенные символы будут записываться левее, так как рекурсия записана левее от f строк

n = int(input())
print(f(n))

# Обяснение Дениса
def reverse_numbers(n):
  if n == 0:
    return ''
  num = int(input()) # Вводим число
  return reverse_numbers(n -1) + f"{num} "

n = int(input("Введите кол-во чисел: "))
print(reverse_numbers(n))
# f(3) -> num = 1   f(2) + "1 " = "3 2 " + "1 " = "3 2 1 "
#                     |                  ^
#                 num = 2   f(1) + "2 " = "3 " + "2 " = "3 2 "
#                             |                ^
#                         num = 3   f(0) + "3 " = "" + "3 " = "3 "
#                                     |              ^
#                                     ""