  # Функция (def)- это фрагмент программы, используемый многократно

  # Задание: 
# Необходимо создать функцию sum_numbers(n), которая будет считать
# сумму всех элементов от 1 до n.

def sum_numbers(n):
  summa = 0
  for i in range(1, n + 1): #(1 так ка нужно посчитать с первого элнмента, n + 1)
    summa += i
  print(summa)

sum_numbers(5) # вызываем функцию


def sum_numbers(n): # Переделали функциючто бы возращала значение
  summa = 0
  for i in range(1, n + 1):
    summa += i
  return summa

a = sum_numbers(5)
print(a)
      # print(sum_numbers(5)) и не указываем переменную a

# Правила функций и процедур - сколько аргументов мпринмаем столько и передаем и наоборот

def sum_numbers(n, y = 'Hello'):  # Если значение не передаеем, то берется значение по умолчанию
  print(y) # Выведется Hello
  summa = 0
  for i in range(1, n + 1):
    summa += i
  return summa

a = sum_numbers(5)
print(a) # И строкой ниже 15


def sum_numbers(n, y = 'Hello'):
  print(y)
  summa = 0
  for i in range(1, n + 1):
    summa += i
  return summa

a = sum_numbers(5, 'qwert') # Если передаеь значение, то переменная имеет значение аргумента который передали
print(a) # 'qwert' И строкой ниже 15

# Функция принемает не ограниченное кол-во аргументов
def sum_str(*args): # * - - что бы передать неограниченное кол-во аргументов
  res = '' # создали переменную с типом данных строка
  for i in args: # пройдем по всем эл переменной args
    res += i # При каждой этерации к переменной добавляем i
  return res 

print(sum('q', 'e', 'l')) # qel
print(sum('q', 'e', 'l', 'r', 'f')) # qelrf
print(sum(1, 2, 3)) # Вызывается ошибка



      # Модули - это вайл, в котором находятся различные функции
# Создали файл с функциями modul1.py
import modul1 # Импортируем иодуль из 
print(modul1.max1(5, 9)) # 9 (modul - обращ к модулю и указываем название функции)

from modul1 import max1 # На прямую импортируем функцию
print(max1(10, 9)) # 10

from modul1 import * # Означает что хотим импортировать все функции
print(max1(10, 9))

import modul1 as m1 # Импортируем modul1 как имя m1
print(m1.max1(5, 9))



      # Рекурсия - это функция, вызывающая сама себя
def fib(n):
  if n [1,2]: # Базис - когда функции надо остановиться и перестать вызывать саму себя
    return 1
  return fib(n - 1) + fib(n - 2) # Последовательность Фибоначчи

list_1 =[] # В список будем записывать числа
for i in range(1, 10):
  list_1.append(fib(i))
print(list_1) # [1, 1, 2, 3, 5, 8, 13, 21, 34]



      # Алгоритмы - набор инструкций для выполнения некоторой задачи.
# Любой фрагмент кода можно назвать алгоритмом

# Алгоритмы сортировки - делим, чтото большое на что то маленькое и вполне реальное

# Два друга играют в игру: один загадывает число от 1 до 100, другой 
# отгадывает. Согласитесь, что мы можем перебирать эти значения в
# случайном порядке, например: 32, 27, 60, 73… Да, мы можем угадать в
# какой-то момент, но что если мы обратиться к стратегии “разделяй и
# властвуй” Обозначим друзей, друг_1 это Иван, который загадал число,
# друг_2 это Петр, который отгадывает.
# Иван загадал число 77
# Петр: Число больше 50? Иван: Да.
# Петр: Число больше 75? Иван: Да.
# Перебераем деля число на 2

def quicksort(array):
  if len(array) <= 1:
    return array
  else:
    pivot = array[0] # В переменной сохраняем первый эл
  less = [i for i in array[1:] if i <= pivot] # В пременной записываем числа которые меньше pivot
  greater = [i for i in array[1:] if i > pivot] # В пременной записываем числа которые больше pivot
  return quicksort(less) + [pivot] + quicksort(greater) # Складываем списки
print(quicksort([10, 5, 2, 3]))

# Сортировка слиянием
def merge_sort(nums):
  if len(nums) > 1:
    mid = len(nums) // 2 # Делем список на 2 пока не останется по 1 эл
    left = nums[:mid] # Сохраняем начало списка
    right = nums[mid:] # Сохраняем конец списка
    merge_sort(left) # С помощю рекурсии делем списки пока не будут по 1 эл
    merge_sort(right)
    i = j = k = 0
    while i < len(left) and j < len(right): # Соединяем все элементы
      if left[i] < right[j]:
        nums[k] = left[i]
        i += 1
      else:
        nums[k] = right[j]
        j += 1
        k += 1

    while i < len(left):
      nums[k] = left[i]
      i += 1
      k += 1

    while j < len(right):
      nums[k] = right[j]
      j += 1
      k += 1
list_1 = [38, 27, 43, 3, 9, 82, 10]
merge_sort(list_1)
print(list_1)













